const axios = require('axios');
const express = require('express');
const Recommendation = require('../models/Recommendation');
const ArtistRecommendation = require('../models/ArtistRecommendation');
const { fetchRecommendations, getCuratedRecommendations, getArtistRecommendations } = require('../utils/fetchRecommendations');

const router = express.Router();

router.get('/top_artists', async (req, res) => {
  const access_token = req.session.access_token;
  if (!access_token) {
    return res.status(401).json({ error: 'No access token - please authenticate with Spotify first' });
  }
  
  const url = "https://api.spotify.com/v1/me/top/artists?limit=10"
  
  const payload = {
    headers: {
      Authorization: `Bearer ${access_token}`,
    }
  };
  
  try {
    const result = await axios.get(url, payload);
    const data = result.data;
    
    // Extract artist names for recommendation system
    const artistNames = data.items.map(artist => artist.name);
    
    console.log(`üìä Retrieved ${artistNames.length} top artists:`, artistNames);
    
    res.json({
      artists: data.items,
      artistNames: artistNames
    });
  } catch (e) {
    console.error("Spotify GET request failed:", e.message);
    return res.status(400).json({ error: "Failed to fetch top artists from Spotify" });
  }
});

// Check which Spotify artists are available and auto-generate if possible
router.post('/check_artists_availability', async (req, res) => {
  const { artistNames, userId } = req.body || {};
  
  if (!Array.isArray(artistNames) || artistNames.length === 0) {
    return res.status(400).json({ error: 'artistNames (array) is required' });
  }

  try {
    const base = process.env.ML_SERVICE_URL;
    if (!base) {
      return res.status(503).json({ error: 'ML service not configured' });
    }

    // Get available artists from ML service
    const url = `${base.replace(/\/$/, '')}/artists`;
    const { data } = await axios.get(url, { timeout: 5000 });
    const availableArtists = new Set(data.artists);

    // Check availability of each Spotify artist
    const availabilityResults = artistNames.map((artistName, index) => ({
      artistName,
      available: availableArtists.has(artistName)
    }));

    const availableArtistsList = availabilityResults.filter(result => result.available);
    const unavailableArtistsList = availabilityResults.filter(result => !result.available);

    console.log(`üéØ Artist availability check: ${availableArtistsList.length}/${artistNames.length} available`);

    // If we have 5+ available artists, auto-generate recommendations
    if (availableArtistsList.length >= 5) {
      console.log(`‚úÖ Auto-generating recommendations with ${availableArtistsList.length} available artists`);
      
      // Generate recommendations immediately
      const recommendations = [];
      const artistNamesForRecs = availableArtistsList.map(a => a.artistName);
      
      for (const artistName of artistNamesForRecs) {
        try {
          const predictUrl = `${base.replace(/\/$/, '')}/predict`;
          const { data: artistData } = await axios.get(predictUrl, { 
            params: { user_id: artistName },
            timeout: 10000 
          });
          
          if (artistData && Array.isArray(artistData.top_items)) {
            recommendations.push(...artistData.top_items.slice(0, 1)); // Take 1 from each to get variety
          }
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to get recommendations for ${artistName}:`, err.message);
        }
      }

      // Remove duplicates and limit to 5 recommendations
      const uniqueRecommendations = [...new Set(recommendations)].slice(0, 5);
      
      // Save to database
      const doc = await Recommendation.create({ 
        userId: userId || 'auto_user',
        likedTracks: artistNamesForRecs,
        recommendations: uniqueRecommendations
      });

      return res.json({
        autoGenerated: true,
        totalArtists: artistNames.length,
        availableCount: availableArtistsList.length,
        unavailableCount: unavailableArtistsList.length,
        availableArtists: availableArtistsList,
        unavailableArtists: unavailableArtistsList,
        recommendations: {
          userId: doc.userId,
          artistNames: doc.likedTracks,
          recommendations: doc.recommendations,
          recommendationCount: doc.recommendations.length,
          algorithm: 'ml-model-similarity',
          createdAt: doc.createdAt
        }
      });
    }

    // If <5 available artists, return availability info for search interface
    res.json({
      autoGenerated: false,
      totalArtists: artistNames.length,
      availableCount: availableArtistsList.length,
      unavailableCount: unavailableArtistsList.length,
      availableArtists: availableArtistsList,
      unavailableArtists: unavailableArtistsList,
      needsMoreArtists: 5 - availableArtistsList.length,
      message: `Need ${5 - availableArtistsList.length} more artists to generate recommendations`
    });
  } catch (err) {
    console.error('‚ùå Failed to check artist availability:', err.message);
    res.status(500).json({ error: 'Failed to check artist availability in dataset' });
  }
});

// Generate recommendations from manually selected artist list (search interface)
router.post('/recommend', async (req, res) => {
  const { userId, artistNames } = req.body || {};
  
  if (typeof userId !== 'string') {
    return res.status(400).json({ error: 'userId (string) is required' });
  }
  
  if (!Array.isArray(artistNames) || artistNames.length < 5) {
    return res.status(400).json({ error: 'artistNames (array) with at least 5 artists is required' });
  }

  try {
    console.log(`üéØ Generating manual recommendations for user ${userId} with ${artistNames.length} artists`);
    
    // Single validation point - ensure all artists exist in dataset
    const baseUrl = process.env.ML_SERVICE_URL;
    if (!baseUrl) {
      return res.status(503).json({ error: 'ML service not configured' });
    }

    const url = `${baseUrl.replace(/\/$/, '')}/artists`;
    const { data } = await axios.get(url, { timeout: 5000 });
    const availableArtists = new Set(data.artists);

    const unavailableArtists = artistNames.filter(artist => !availableArtists.has(artist));
    if (unavailableArtists.length > 0) {
      return res.status(400).json({ 
        error: 'Some artists are not available in the dataset',
        unavailableArtists,
        message: `Please remove these artists: ${unavailableArtists.join(', ')}`
      });
    }

    // Generate recommendations using the ML model
    const recommendations = [];
    
    // Get top 2 tracks from each artist for variety
    for (const artistName of artistNames) {
      try {
        const predictUrl = `${baseUrl.replace(/\/$/, '')}/predict`;
        const { data: artistData } = await axios.get(predictUrl, { 
          params: { user_id: artistName },
          timeout: 10000 
        });
        
        if (artistData && Array.isArray(artistData.top_items)) {
          recommendations.push(...artistData.top_items.slice(0, 2));
        }
      } catch (err) {
        console.warn(`‚ö†Ô∏è Failed to get recommendations for ${artistName}:`, err.message);
      }
    }

    // Remove duplicates and limit to 5 recommendations
    const uniqueRecommendations = [...new Set(recommendations)].slice(0, 5);
    
    // Save to database
    const doc = await Recommendation.create({ 
      userId, 
      likedTracks: artistNames,
      recommendations: uniqueRecommendations
    });
    
    console.log(`‚úÖ Successfully generated ${uniqueRecommendations.length} manual recommendations for user ${userId}`);
    
    return res.status(201).json({
      userId: doc.userId,
      artistNames: doc.likedTracks,
      recommendations: doc.recommendations,
      recommendationCount: doc.recommendations.length,
      algorithm: 'ml-model-similarity',
      source: 'manual_selection',
      createdAt: doc.createdAt
    });
  } catch (err) {
    console.error('‚ùå Recommendation generation error:', err);
    return res.status(500).json({ error: 'Failed to generate recommendations' });
  }
});

// Legacy endpoint for backward compatibility
router.post('/recommend/legacy', async (req, res) => {
  const { userId, likedTracks } = req.body || {};
  if (typeof userId !== 'string' || !Array.isArray(likedTracks)) {
    return res.status(400).json({ error: 'userId (string) and likedTracks (array) required' });
  }

  try {
    const recs = await fetchRecommendations(userId, likedTracks);
    const doc = await Recommendation.create({ userId, likedTracks, recommendations: recs });
    return res.status(201).json(doc);
  } catch (err) {
    console.error('‚ùå DB error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Search artists in the dataset
router.get('/artists/search', async (req, res) => {
  const { q: query, limit = 10 } = req.query;
  
  if (!query || query.trim().length < 2) {
    return res.status(400).json({ error: 'Query parameter "q" is required and must be at least 2 characters' });
  }

  try {
    const base = process.env.ML_SERVICE_URL;
    if (!base) {
      return res.status(503).json({ error: 'ML service not configured' });
    }

    const url = `${base.replace(/\/$/, '')}/artists`;
    const { data } = await axios.get(url, { timeout: 5000 });
    
    // Filter artists based on query (case-insensitive)
    const searchQuery = query.toLowerCase();
    const matchingArtists = data.artists
      .filter(artist => artist.toLowerCase().includes(searchQuery))
      .slice(0, parseInt(limit))
      .map(artist => ({
        name: artist,
        matchType: artist.toLowerCase() === searchQuery ? 'exact' : 'partial'
      }));

    console.log(`üîç Artist search for "${query}": found ${matchingArtists.length} results`);

    res.json({
      query,
      results: matchingArtists,
      count: matchingArtists.length,
      totalAvailable: data.artists.length
    });
  } catch (err) {
    console.error('‚ùå Failed to search artists:', err.message);
    res.status(500).json({ error: 'Failed to search artists in dataset' });
  }
});

// Get all available artists (for debugging/admin purposes)
router.get('/artists/available', async (req, res) => {
  try {
    const base = process.env.ML_SERVICE_URL;
    if (!base) {
      return res.status(503).json({ error: 'ML service not configured' });
    }

    const url = `${base.replace(/\/$/, '')}/artists`;
    const { data } = await axios.get(url, { timeout: 5000 });
    
    res.json({
      availableArtists: data.artists,
      count: data.artists.length
    });
  } catch (err) {
    console.error('‚ùå Failed to fetch available artists:', err.message);
    res.status(500).json({ error: 'Failed to fetch available artists from ML service' });
  }
});

router.get('/artists/cached', async (req, res) => {
  try {
    const cached = await ArtistRecommendation.find({}).select('artistName cachedAt lastAccessed');
    res.json({
      cachedArtists: cached,
      count: cached.length
    });
  } catch (err) {
    console.error('‚ùå Failed to fetch cached artists:', err.message);
    res.status(500).json({ error: 'Failed to fetch cached artists' });
  }
});

router.post('/artists/cache/:artistName', async (req, res) => {
  const { artistName } = req.params;
  
  if (!artistName) {
    return res.status(400).json({ error: 'Artist name is required' });
  }

  try {
    console.log(`üîÑ Manually caching recommendations for artist: ${artistName}`);
    const recommendations = await getArtistRecommendations(artistName);
    
    res.json({
      artistName,
      recommendations,
      cached: true,
      message: `Successfully cached ${recommendations.length} recommendations for ${artistName}`
    });
  } catch (err) {
    console.error(`‚ùå Failed to cache artist ${artistName}:`, err.message);
    res.status(500).json({ error: `Failed to cache recommendations for ${artistName}` });
  }
});

router.delete('/artists/cache/:artistName', async (req, res) => {
  const { artistName } = req.params;
  
  try {
    const result = await ArtistRecommendation.deleteOne({ artistName });
    
    if (result.deletedCount === 0) {
      return res.status(404).json({ error: `No cached recommendations found for ${artistName}` });
    }
    
    res.json({
      message: `Successfully deleted cached recommendations for ${artistName}`,
      deletedCount: result.deletedCount
    });
  } catch (err) {
    console.error(`‚ùå Failed to delete cache for ${artistName}:`, err.message);
    res.status(500).json({ error: `Failed to delete cached recommendations for ${artistName}` });
  }
});

router.delete('/artists/cache', async (req, res) => {
  try {
    const result = await ArtistRecommendation.deleteMany({});
    
    res.json({
      message: 'Successfully cleared all cached artist recommendations',
      deletedCount: result.deletedCount
    });
  } catch (err) {
    console.error('‚ùå Failed to clear cache:', err.message);
    res.status(500).json({ error: 'Failed to clear cached recommendations' });
  }
});

module.exports = router;